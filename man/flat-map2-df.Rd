% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/flat-map2.R, R/flat-pmap.R
\name{flat-map2-df}
\alias{flat-map2-df}
\alias{flat_map2_row}
\alias{flat_map2_col}
\alias{flat_pmap_row}
\alias{flat_pmap_col}
\title{Flat map multiple inputs simultaneouly and convert to a data frame}
\usage{
flat_map2_row(.x, .y, .f, ..., .ptype = NULL, .names_to = NULL,
  .name_repair = c("unique", "universal", "check_unique"))

flat_map2_col(.x, .y, .f, ..., .ptype = NULL, .size = NULL,
  .name_repair = c("unique", "universal", "check_unique", "minimal"))

flat_pmap_row(.l, .f, ..., .ptype = NULL, .names_to = NULL,
  .name_repair = c("unique", "universal", "check_unique"))

flat_pmap_col(.l, .f, ..., .ptype = NULL, .size = NULL,
  .name_repair = c("unique", "universal", "check_unique", "minimal"))
}
\arguments{
\item{.x, .y}{Vectors of the same length. A vector of length 1 will be
recycled.}

\item{.f}{A function, formula, or vector (not necessarily atomic).

If a \strong{function}, it is used as is.

If a \strong{formula}, e.g. \code{~ .x + 2}, it is converted to a function. There
are three ways to refer to the arguments:
\itemize{
\item For a single argument function, use \code{.}
\item For a two argument function, use \code{.x} and \code{.y}
\item For more arguments, use \code{..1}, \code{..2}, \code{..3} etc
}

This syntax allows you to create very compact anonymous functions.

If \strong{character vector}, \strong{numeric vector}, or \strong{list}, it is
converted to an extractor function. Character vectors index by
name and numeric vectors index by position; use a list to index
by position and name at different levels. If a component is not
present, the value of \code{.default} will be returned.}

\item{...}{Additional arguments passed on to the mapped function.}

\item{.ptype}{If \code{NULL}, the default, the output type is determined by
computing the common type across all elements of \code{...}.

Alternatively, you can supply \code{.ptype} to give the output known type.
If \code{getOption("vctrs.no_guessing")} is \code{TRUE} you must supply this value:
this is a convenient way to make production code demand fixed types.}

\item{.names_to}{Optionally, the name of a column where the names
of \code{...} arguments are copied. These names are useful to identify
which row comes from which input. If supplied and \code{...} is not named,
an integer column is used to identify the rows.}

\item{.name_repair}{One of \code{"unique"}, \code{"universal"}, or
\code{"check_unique"}. See \code{\link[=vec_as_names]{vec_as_names()}} for the meaning of these
options.

With \code{vec_rbind()}, the repair function is applied to all inputs
separately. This is because \code{vec_rbind()} needs to align their
columns before binding the rows, and thus needs all inputs to
have unique names. On the other hand, \code{vec_cbind()} applies the
repair function after all inputs have been concatenated together
in a final data frame. Hence \code{vec_cbind()} allows the more
permissive minimal names repair.}

\item{.size}{If, \code{NULL}, the default, will determine the number of
rows in \code{vec_cbind()} output by using the standard recycling rules.

Alternatively, specify the desired number of rows, and any inputs
of length 1 will be recycled appropriately.}

\item{.l}{A list of vectors, such as a data frame. The length of \code{.l}
determines the number of arguments that \code{.f} will be called with. List
names will be used if present.}
}
\description{
These functions are variants of \code{\link[=flat_map_row]{flat_map_row()}} and \code{\link[=flat_map_col]{flat_map_col()}} that
iterate over multiple arguments simultaneously.
}
\examples{
flat_map2_row(list(1, 2:3), list(4, 5:6), ~data.frame(x = .x, y = .y))
}
