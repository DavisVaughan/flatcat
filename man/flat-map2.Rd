% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fmap2.R, R/pfmap.R
\name{flat-map2}
\alias{flat-map2}
\alias{fmap2_vec}
\alias{fmap2_lst}
\alias{fmap2_dbl}
\alias{fmap2_int}
\alias{fmap2_chr}
\alias{fmap2_lgl}
\alias{pfmap_vec}
\alias{pfmap_lst}
\alias{pfmap_dbl}
\alias{pfmap_int}
\alias{pfmap_chr}
\alias{pfmap_lgl}
\title{Flat map over multiple inputs simultaneously}
\usage{
fmap2_vec(.x, .y, .f, ..., .ptype = NULL, .name_spec = NULL,
  .name_repair = c("minimal", "unique", "check_unique", "universal"))

fmap2_lst(.x, .y, .f, ..., .name_spec = NULL,
  .name_repair = c("minimal", "unique", "check_unique", "universal"))

fmap2_dbl(.x, .y, .f, ..., .name_spec = NULL,
  .name_repair = c("minimal", "unique", "check_unique", "universal"))

fmap2_int(.x, .y, .f, ..., .name_spec = NULL,
  .name_repair = c("minimal", "unique", "check_unique", "universal"))

fmap2_chr(.x, .y, .f, ..., .name_spec = NULL,
  .name_repair = c("minimal", "unique", "check_unique", "universal"))

fmap2_lgl(.x, .y, .f, ..., .name_spec = NULL,
  .name_repair = c("minimal", "unique", "check_unique", "universal"))

pfmap_vec(.l, .f, ..., .ptype = NULL, .name_spec = NULL,
  .name_repair = c("minimal", "unique", "check_unique", "universal"))

pfmap_lst(.l, .f, ..., .name_spec = NULL, .name_repair = c("minimal",
  "unique", "check_unique", "universal"))

pfmap_dbl(.l, .f, ..., .name_spec = NULL, .name_repair = c("minimal",
  "unique", "check_unique", "universal"))

pfmap_int(.l, .f, ..., .name_spec = NULL, .name_repair = c("minimal",
  "unique", "check_unique", "universal"))

pfmap_chr(.l, .f, ..., .name_spec = NULL, .name_repair = c("minimal",
  "unique", "check_unique", "universal"))

pfmap_lgl(.l, .f, ..., .name_spec = NULL, .name_repair = c("minimal",
  "unique", "check_unique", "universal"))
}
\arguments{
\item{.x, .y}{Vectors of the same length. A vector of length 1 will be
recycled.}

\item{.f}{A function, formula, or vector (not necessarily atomic).

If a \strong{function}, it is used as is.

If a \strong{formula}, e.g. \code{~ .x + 2}, it is converted to a function. There
are three ways to refer to the arguments:
\itemize{
\item For a single argument function, use \code{.}
\item For a two argument function, use \code{.x} and \code{.y}
\item For more arguments, use \code{..1}, \code{..2}, \code{..3} etc
}

This syntax allows you to create very compact anonymous functions.

If \strong{character vector}, \strong{numeric vector}, or \strong{list}, it is
converted to an extractor function. Character vectors index by
name and numeric vectors index by position; use a list to index
by position and name at different levels. If a component is not
present, the value of \code{.default} will be returned.}

\item{...}{Additional arguments passed on to the mapped function.}

\item{.ptype}{If \code{NULL}, the default, the output type is determined by
computing the common type across all elements of \code{...}.

Alternatively, you can supply \code{.ptype} to give the output known type.
If \code{getOption("vctrs.no_guessing")} is \code{TRUE} you must supply this value:
this is a convenient way to make production code demand fixed types.}

\item{.name_spec}{A name specification for combining
inner and outer names. This is relevant for inputs passed with a
name, when these inputs are themselves named, like \code{outer = c(inner = 1)}, or when they have length greater than 1: \code{outer = 1:2}. By default, these cases trigger an error. You can resolve
the error by providing a specification that describes how to
combine the names or the indices of the inner vector with the
name of the input. This specification can be:
\itemize{
\item A function of two arguments. The outer name is passed as a
string to the first argument, and the inner names or positions
are passed as second argument.
\item An anonymous function as a purrr-style formula.
\item A glue specification of the form \code{"{outer}_{inner}"}.
}

See the \link[=name_spec]{name specification topic}.}

\item{.name_repair}{How to repair names, see \code{repair} options in \code{\link[=vec_as_names]{vec_as_names()}}.}

\item{.l}{A list of vectors, such as a data frame. The length of \code{.l}
determines the number of arguments that \code{.f} will be called with. List
names will be used if present.}
}
\description{
These functions are variants of \code{\link[=fmap_vec]{fmap_vec()}} that iterate over multiple
arguments simultaneously.
}
\examples{
# Interleave vectors (but this isn't that efficient)
fmap2_dbl(1:5, 6:10, ~c(.x, .y))

}
