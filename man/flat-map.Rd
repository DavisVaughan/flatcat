% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fmap.R
\name{flat-map}
\alias{flat-map}
\alias{fmap_vec}
\alias{fmap_lst}
\alias{fmap_dbl}
\alias{fmap_int}
\alias{fmap_chr}
\alias{fmap_lgl}
\title{Flat map}
\usage{
fmap_vec(.x, .f, ..., .ptype = NULL, .name_spec = NULL,
  .name_repair = c("minimal", "unique", "check_unique", "universal"))

fmap_lst(.x, .f, ..., .name_spec = NULL, .name_repair = c("minimal",
  "unique", "check_unique", "universal"))

fmap_dbl(.x, .f, ..., .name_spec = NULL, .name_repair = c("minimal",
  "unique", "check_unique", "universal"))

fmap_int(.x, .f, ..., .name_spec = NULL, .name_repair = c("minimal",
  "unique", "check_unique", "universal"))

fmap_chr(.x, .f, ..., .name_spec = NULL, .name_repair = c("minimal",
  "unique", "check_unique", "universal"))

fmap_lgl(.x, .f, ..., .name_spec = NULL, .name_repair = c("minimal",
  "unique", "check_unique", "universal"))
}
\arguments{
\item{.x}{A list or atomic vector.}

\item{.f}{A function, formula, or vector (not necessarily atomic).

If a \strong{function}, it is used as is.

If a \strong{formula}, e.g. \code{~ .x + 2}, it is converted to a function. There
are three ways to refer to the arguments:
\itemize{
\item For a single argument function, use \code{.}
\item For a two argument function, use \code{.x} and \code{.y}
\item For more arguments, use \code{..1}, \code{..2}, \code{..3} etc
}

This syntax allows you to create very compact anonymous functions.

If \strong{character vector}, \strong{numeric vector}, or \strong{list}, it is
converted to an extractor function. Character vectors index by
name and numeric vectors index by position; use a list to index
by position and name at different levels. If a component is not
present, the value of \code{.default} will be returned.}

\item{...}{Vectors to coerce.}

\item{.ptype}{If \code{NULL}, the default, the output type is determined by
computing the common type across all elements of \code{...}.

Alternatively, you can supply \code{.ptype} to give the output known type.
If \code{getOption("vctrs.no_guessing")} is \code{TRUE} you must supply this value:
this is a convenient way to make production code demand fixed types.}

\item{.name_spec}{A name specification for combining
inner and outer names. This is relevant for inputs passed with a
name, when these inputs are themselves named, like \code{outer = c(inner = 1)}, or when they have length greater than 1: \code{outer = 1:2}. By default, these cases trigger an error. You can resolve
the error by providing a specification that describes how to
combine the names or the indices of the inner vector with the
name of the input. This specification can be:
\itemize{
\item A function of two arguments. The outer name is passed as a
string to the first argument, and the inner names or positions
are passed as second argument.
\item An anonymous function as a purrr-style formula.
\item A glue specification of the form \code{"{outer}_{inner}"}.
}

See the \link[=name_spec]{name specification topic}.}

\item{.name_repair}{How to repair names, see \code{repair} options in \code{\link[=vec_as_names]{vec_as_names()}}.}
}
\description{
Flat map is similar to map, except that the size restriction on the output
of each \code{.f} call is lifted. This means that rather than requiring a result
of size \code{1} from each function call, a flat map can return an object of
arbitrary size.
}
\section{Invariants}{

\itemize{
\item \code{vec_size(fmap_vec(.x, .f)) == sum(map_int(map(.x, .f), vec_size))}
\item \code{vec_ptype(fmap_vec(.x, .ptype = ptype)) == ptype \%||\% vec_ptype_common(!!! map(.x, .f))}
}
}

\examples{
# `map()` functions require that each result from `.f` have size 1
try(map_dbl(list(1, 2:3, 4:6), ~.x))

# `fmap_dbl()` and friends don't care
fmap_dbl(list(1, 2:3, 4:6), ~.x)

# Returning arbitrary output types
fmap_vec(1:3, ~Sys.Date() + seq(0, .x))

# Returning data frames of arbitrary sizes
fmap_vec(1:3, ~data.frame(x = seq_len(.x)))

# Name repair if required
fmap_dbl(list(x = 1, x = 2), ~c(a = .x), .name_spec = "{outer}_{inner}")
}
